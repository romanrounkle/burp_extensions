from burp import IBurpExtender
from burp import IScannerCheck
from burp import IScanIssue
from burp import IParameter
from array import array

GREP_STRING = "Page generated by:"
GREP_STRING_BYTES = bytearray(GREP_STRING)
INJ_TEST = bytearray("NotSessionValue")
INJ_ERROR = "Unexpected pipe"
INJ_ERROR_BYTES = bytearray(INJ_ERROR)

class BurpExtender(IBurpExtender, IScannerCheck):

    #
    # implement IBurpExtender
    #

    def registerExtenderCallbacks(self, callbacks):
        # keep a reference to our callbacks object
        self._callbacks = callbacks

        # obtain an extension helpers object
        self._helpers = callbacks.getHelpers()

        # set our extension name
        callbacks.setExtensionName("Session Obsession V0.5")

        # register ourselves as a custom scanner check
        callbacks.registerScannerCheck(self)

    # helper method to search a response for occurrences of a literal match string
    # and return a list of start/end offsets

    def _get_matches(self, response, match):
        matches = []
        start = 0
        reslen = len(response)
        matchlen = len(match)
        while start < reslen:
            start = self._helpers.indexOf(response, match, True, start, reslen)
            if start == -1:
                break
            matches.append(array('i', [start, start + matchlen]))
            start += matchlen

        return matches

    #
    # implement IScannerCheck
    #


    def doActiveScan(self, baseRequestResponse, insertionPoint):

	
	# Get size of response without payload. 
	response = baseRequestResponse.getResponse()
	request = baseRequestResponse.getRequest()
       	checkRequest = insertionPoint.buildRequest("NotSessionValue")
       	checkRequestResponse = self._callbacks.makeHttpRequest(
               	baseRequestResponse.getHttpService(), checkRequest)
	modRequest = checkRequestResponse.getRequest()
	modResponse = checkRequestResponse.getResponse()

	# check stability
	unstableReq = 0
	for i in range(3):
		print "[+] Stability check :",i
		stabilityRequestResponse = self._callbacks.makeHttpRequest(baseRequestResponse.getHttpService(), request)
		stabilityRequestResponse = stabilityRequestResponse.getResponse()
		if len(self._helpers.bytesToString(stabilityRequestResponse)) != len(self._helpers.bytesToString(response)):
			unstableReq += 1
		else: 	
			print "[+] The environment is stable"


        if unstableReq > 0:
		print "[-] Sorry the response is not stable"
        else:
        	requestInfo = self._helpers.analyzeRequest(checkRequestResponse) 
        	param = requestInfo.getParameters()                             
        	param = list(param)                                             
		sessionidstringlist = ""
		unusedsessionidstringlist = ""
        	for p in param:                                                 
                	if p.getValue() == "NotSessionValue" and p.getType() == 2:                       
				if len(self._helpers.bytesToString(modResponse)) != len(self._helpers.bytesToString(response)):
					print "[+] Found a sessions cookie: ",p.getName()
					sessionidstring = str(p.getName())
					unusedsessionidstring = str(p.getName())
					sessionidstringlist += sessionidstring + "="
					unusedsessionidstringlist += unusedsessionidstring + "="
					# Get the value of the session cookie
					SessionIDRequestResponse = self._callbacks.makeHttpRequest(baseRequestResponse.getHttpService(), request)
					SessionIDRequestResponse = self._helpers.analyzeRequest(SessionIDRequestResponse)
					paramSessionID = SessionIDRequestResponse.getParameters()
					paramSessionID = list(paramSessionID)
					for psi in paramSessionID:
						if psi.getName() == p.getName():
							print "[+] The original value of the cookie is",psi.getValue()
							psiValue = str(psi.getValue())
							# sessionidstringlist += psiValue
							# sessionidstringlist += "; "
							# iterate through session cookie
							UsedChars = ""
							NotUsedChars = ""
							for c in range(len(psiValue)):
								psiValueMod = list(psiValue)
								psiValueOrg = psiValueMod[c]
								if psiValueMod[c] != "A":
									psiValueMod[c] = "A"
								else: 
									psiValueMod[c] = "B"
								psiValueModStr = ''.join(psiValueMod)
								print "[+] Char: ",psiValueModStr
								# frobber requests
								frobberRequest = insertionPoint.buildRequest(psiValueModStr)
								frobberRequestResponse = self._callbacks.makeHttpRequest(baseRequestResponse.getHttpService(), frobberRequest)
								frobberResponse = frobberRequestResponse.getResponse()
								if len(self._helpers.bytesToString(frobberResponse)) != len(self._helpers.bytesToString(response)):
									UsedChars +=  psiValueOrg
								else: 
									NotUsedChars += psiValueOrg

							sessionidstringlist += UsedChars
							sessionidstringlist += "; "
							unusedsessionidstringlist += NotUsedChars
							unusedsessionidstringlist += "; "
							
					#print used and unused string
					print "[+] Used characters in session value: ",UsedChars
					print "[+] Not Used characters in session value: ",NotUsedChars

					if len(NotUsedChars) > 0:
						resultMessage = "The following cookies are involved in the session or the output of the response.<br/> The value is cropped to only include the section that is used to mainting the session.<br/><br/>" + sessionidstringlist + "<br/><br/>Unused part of the session ID value: " + unusedsessionidstringlist
					else: 
						resultMessage = "The following cookies are involved in the session or the output of the response.<br/> The value is cropped to only include the section that is used to mainting the session.<br/><br/>" + sessionidstringlist


       					# get the offsets of the payload within the request, for in-UI highlighting
       					requestHighlights = [insertionPoint.getPayloadOffsets(INJ_TEST)]

       					# report the issue
       					return [CustomScanIssue(
            					baseRequestResponse.getHttpService(),
            					self._helpers.analyzeRequest(baseRequestResponse).getUrl(),
            					[],
            					"Session ID cookie found",
            					resultMessage,
            					"Information")]
	

    def consolidateDuplicateIssues(self, existingIssue, newIssue):
        # This method is called when multiple issues are reported for the same URL 
        # path by the same extension-provided check. The value we return from this 
        # method determines how/whether Burp consolidates the multiple issues
        # to prevent duplication
        #
        # Since the issue name is sufficient to identify our issues as different,
        # if both issues have the same name, only report the existing issue
        # otherwise report both issues
        if existingIssue.getIssueName() == newIssue.getIssueName():
            return -1

        return 0

#
# class implementing IScanIssue to hold our custom scan issue details
#
class CustomScanIssue (IScanIssue):
    def __init__(self, httpService, url, httpMessages, name, detail, severity):
        self._httpService = httpService
        self._url = url
        self._httpMessages = httpMessages
        self._name = name
        self._detail = detail
        self._severity = severity

    def getUrl(self):
        return self._url

    def getIssueName(self):
        return self._name

    def getIssueType(self):
        return 0

    def getSeverity(self):
        return self._severity

    def getConfidence(self):
        return "Certain"

    def getIssueBackground(self):
        pass

    def getRemediationBackground(self):
        pass

    def getIssueDetail(self):
        return self._detail

    def getRemediationDetail(self):
        pass

    def getHttpMessages(self):
        return self._httpMessages

    def getHttpService(self):
        return self._httpService

